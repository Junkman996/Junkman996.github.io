<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo写作经验积累</title>
      <link href="/2022/11/25/hexo-xie-zuo-jing-yan-ji-lei/"/>
      <url>/2022/11/25/hexo-xie-zuo-jing-yan-ji-lei/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/writing">Hexo官方文档</a></p><h2 id="1-布局（Layout）"><a href="#1-布局（Layout）" class="headerlink" title="1. 布局（Layout）"></a>1. 布局（Layout）</h2><h3 id="1-1-三种布局及简单使用"><a href="#1-1-三种布局及简单使用" class="headerlink" title="1.1 三种布局及简单使用"></a>1.1 三种布局及简单使用</h3><p>Hexo有三种默认布局：post、page和draft。在创建三种不同类型文件时，会被分别保存在不同路径下。</p><table><thead><tr><th align="center">布局</th><th align="center">路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">source/_posts</td></tr><tr><td align="center">page</td><td align="center">source</td></tr><tr><td align="center">draft</td><td align="center">source/_drafts</td></tr></tbody></table><p>可通过执行下列命令创建新的文章或页面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不指定[layout]会默认使用_config.yml中的default_layout参数所指定的默认布局。</p><p>另外草稿（draft）不会显示在页面中，可以执行时加上–draft参数，或是把render_drafts参数设为true来预览草稿。<br>可以通过publish命令将草稿移动到source/_posts文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-布局配置修改"><a href="#1-2-布局配置修改" class="headerlink" title="1.2 布局配置修改"></a>1.2 布局配置修改</h3><p>scaffolds目录下有若干md文件，分别对应各种布局的默认front-matter</p><h3 id="1-3-建立自定义布局（模板Scaffold）"><a href="#1-3-建立自定义布局（模板Scaffold）" class="headerlink" title="1.3 建立自定义布局（模板Scaffold）"></a>1.3 建立自定义布局（模板Scaffold）</h3><h2 id="2-访问密码（hexo-blog-encrypt）"><a href="#2-访问密码（hexo-blog-encrypt）" class="headerlink" title="2. 访问密码（hexo-blog-encrypt）"></a>2. 访问密码（hexo-blog-encrypt）</h2><p><a href="https://easyhexo.com/3-Plugins-use-and-config/3-4-hexo-blog-encrypt/"></a></p><ul><li><code>npm install --save hexo-blog-encrypt</code></li></ul><p>另外需要将matery主题目录下_config.yml文件的verifyPassword选项取消激活，改为false。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阅读论文积累词汇</title>
      <link href="/2022/11/24/yue-du-lun-wen-ji-lei-ci-hui/"/>
      <url>/2022/11/24/yue-du-lun-wen-ji-lei-ci-hui/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="07d09953845ad9e5eafe646a238e999d1b5cbc146b85f102271aa244d36d28af">b567c004ca2bb5b08891a8e064d889d4466d4ca95cda102db39893629d448535f3b0f83439ecaafc67e851a1d982b794dda1a007cdabf56477bd17c6032f170eb56800beff8e9f450b062601670464c46498a9008adfc345b88b67bb27ee35f34d63d04b0970ec5b2bdd4cc1cc4e1af0c553f4749356effd8b3764efd15f20f5870203c896d130045c1aa62b1a4714cf9ff1f85219849da3ffe69f5a82099530878e766d5983f8a50e779c5cbc4c98aa524f33a7c1ddb47362d0a6fe5959feeece6b4bf0249b42433a204dca5b82c817af6b37e160e0a5c77daed23bef9b350117442a9af73747447a4dc958a90aa05f8db6cc884b3fc48d147f563bc1c4e1a3c6e830dd993865b89223ff10e1e64f0093be29f35342c2f55c5cd776e7e9c46611e5677f78d74a8cab9f0844f5207d0c73aa11bd7ebef521664c81d13ec7339e4f487c40c01a035c197bab5c4a481d245aeda65e5bf56cb43961036e96048531e96c9ee92bb4910c6ca8ee8afb9c034aba0c6f36f10fca28fd7f3df00cbf03072418841676403af929e36a0d28de6529889965381496a485d881123cd9f94807a2e1efd48abffc7a8c16f41dfdea4fe50ba6700363497f35ae3a2cf0f7f08bf246fb551f8efbe891e337c3736baa15cb8388873a45dddc2da87c95c06755bc0d6d1d0c13150dd338ddc51903b5874775e10b5fa4d9067cefb9831069fafbb9a8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">You must enter the password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>‘Typora使用经验积累’</title>
      <link href="/2022/11/23/typora-shi-yong-jing-yan-ji-lei/"/>
      <url>/2022/11/23/typora-shi-yong-jing-yan-ji-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1. 代码块"></a>1. 代码块</h1><p>连续输入三个‘~’再输入想使用的语言，代码块建成之后也可在右下角手动修改所用语言。</p><h1 id="2-MathType公式复制到Typora"><a href="#2-MathType公式复制到Typora" class="headerlink" title="2. MathType公式复制到Typora"></a>2. MathType公式复制到Typora</h1><ol><li><p>在MathType打好公式并复制，需在MathType中将复制格式修改为PlainTex</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123153510409.png" alt="image-20221123153510409"></p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123153127939.png" alt="image-20221123153127939"></p></li><li><p>粘贴到MathType会这样显示：<br><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154440805.png" alt="image-20221123154440805"><br>Typora不会将粘贴过来的$$识别为公式栏，需手动输入$$并按回车创建公式栏</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154657476.png" alt="image-20221123154657476"><br>然后将复制过来的文本删除两端的$$粘贴到公式栏<br><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154805596.png" alt="image-20221123154805596"></p><h1 id="3-条件概率"><a href="#3-条件概率" class="headerlink" title="3. 条件概率"></a>3. 条件概率</h1><p>菜单栏：编辑-&gt;插入符号</p><h1 id="4-与Hexo的小冲突"><a href="#4-与Hexo的小冲突" class="headerlink" title="4. 与Hexo的小冲突"></a>4. 与Hexo的小冲突</h1><p>写公式时可能会出现’{ {‘的字符串，会报错</p><p><img src="C:\Users\23509\AppData\Roaming\Typora\typora-user-images\image-20221123161536878.png" alt="image-20221123161536878"></p><p><a href="https://so.csdn.net/so/search?q=hexo&amp;spm=1001.2101.3001.7020">hexo</a> 的文章渲染使用的是 <code>Nunjucks</code> ，因为在使用<code>mathjax</code>公式，造成了<code>{ {</code>重叠，而它会在生成文章时将那几个大括号识别成自己的语法，这样就会报错。</p><p>用空格隔开就好；</p>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathType书写公式经验记录</title>
      <link href="/2022/11/23/mathtype-shu-xie-gong-shi-jing-yan-ji-lu/"/>
      <url>/2022/11/23/mathtype-shu-xie-gong-shi-jing-yan-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-中-英文状态下输入"><a href="#1-中-英文状态下输入" class="headerlink" title="1. 中/英文状态下输入"></a>1. 中/英文状态下输入</h1><p>中文状态下输入字母不是斜体的，书写公式时建议切换输入法至英文状态。</p><h1 id="2-常用快捷键"><a href="#2-常用快捷键" class="headerlink" title="2. 常用快捷键"></a>2. 常用快捷键</h1><h2 id="2-1-最常用（Ctrl-字母）"><a href="#2-1-最常用（Ctrl-字母）" class="headerlink" title="2.1 最常用（Ctrl+字母）"></a>2.1 最常用（Ctrl+字母）</h2><p>Tab跳格<br>[Ctrl+H]上标    [Ctrl+L]下标    [Ctrl+J]上下标<br>[Ctrl+9/0]小括号()    [Ctrl+[ ]中括号[]    [Ctrl+shift+[ ]大括号{}        注：ctrl快捷键输出的括号和通常使用shift输出的括号是不一样的。<br>[Ctrl+R]根号radical    [CTRL+F]分式fractional    [Ctrl+/]斜杠分式</p><h2 id="2-2-次常用（前缀键，字母）"><a href="#2-2-次常用（前缀键，字母）" class="headerlink" title="2.2 次常用（前缀键，字母）"></a>2.2 次常用（前缀键，字母）</h2><h2 id="2-3-希腊字母的快捷键（Ctrl-G，字母）"><a href="#2-3-希腊字母的快捷键（Ctrl-G，字母）" class="headerlink" title="2.3 希腊字母的快捷键（Ctrl+G，字母）"></a>2.3 希腊字母的快捷键（Ctrl+G，字母）</h2>]]></content>
      
      
      <categories>
          
          <category> MathType </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>白板推导1-1 绪论</title>
      <link href="/2022/11/23/bai-ban-tui-dao-1-1-xu-lun/"/>
      <url>/2022/11/23/bai-ban-tui-dao-1-1-xu-lun/</url>
      
        <content type="html"><![CDATA[<p>对概率的诠释有两大学派：频率派和贝叶斯派。</p><p>后续对观测集采用下面记号：<br>$$<br>{X_{N \times p}} = {\left( { {x_1},{x_2}, \cdots ,{x_N}} \right)^T},{x_i} = {\left( { {x_{i1}},{x_{i2}}, \cdots ,{x_{ip}}} \right)^T}<br>$$<br>这个记号表示有N个样本，每个样本都是p维向量。其中每个观测都是由p(x|θ)生成的。</p>]]></content>
      
      
      <categories>
          
          <category> 白板推导 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Difference between working directory and local repository</title>
      <link href="/2022/11/23/difference-between-working-directory-and-local-repository/"/>
      <url>/2022/11/23/difference-between-working-directory-and-local-repository/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093910760.png" alt="image-20221123093910760"></p><p><strong>working directory（workspace）</strong>：workspace = working directory = project folder，其实就是本地电脑里的文件<br><strong>repository</strong>：实际上就是working directory里的.git隐藏文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093045549.png" alt="image-20221123093045549"></p><p><strong>Step 1: Creating a working directory/workspace</strong></p><p>在本地<strong>新建文件夹</strong>即可实现</p><p><strong>Step 2: Creating a repository</strong></p><p>git commit可在本地生成一个.git文件夹，实际上就是local repository</p><p><strong>Step 3: The working directory and repository in depth</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093412241.png" alt="image-20221123093412241"></p><p><strong>Step 4: Adding a file</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093458051.png" alt="image-20221123093458051"></p><p>在本地新建example.txt文件，这时只在working directory（本地），还没有被add到repository，不能对其进行版本管理。</p><p><strong>Step 5: Adding the file to our repository</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093641206.png" alt="image-20221123093641206"></p><p>git add可实现将example.txt从working directory<strong>复制</strong>到local repository，这样example.txt就可以被Git追踪了</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令解释与踩坑记录</title>
      <link href="/2022/11/22/git-ming-ling-jie-shi-yu-cai-keng-ji-lu/"/>
      <url>/2022/11/22/git-ming-ling-jie-shi-yu-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221122200729751.png"></p><h2 id="1-删除remote-repository的某个文件"><a href="#1-删除remote-repository的某个文件" class="headerlink" title="1. 删除remote repository的某个文件"></a>1. 删除remote repository的某个文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> test.txt<span class="token comment">#在实践中，该命令将workspace和local repository中的文件都删除了</span><span class="token comment">##然后commit+push</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode135：分发糖果</title>
      <link href="/2022/11/13/leetcode135-fen-fa-tang-guo/"/>
      <url>/2022/11/13/leetcode135-fen-fa-tang-guo/</url>
      
        <content type="html"><![CDATA[<p>规则定义：设学生 A 和学生 B 左右相邻，A 在 B 左边；<br>        左规则：当rating<del>B</del> &gt; rating<del>A</del>时，B的糖果比A的糖果数量多。<br>        右规则：当rating<del>A</del> &gt; rating<del>B</del>时，A的糖果比B的糖果数量多。</p><p>相邻的学生中，评分高的学生必须获得更多的糖果 <strong>等价于</strong> 所有学生满足左规则且满足右规则。</p><p>算法流程：</p><ol><li>先从左至右遍历学生成绩 ratings，按照以下规则给糖，并记录在 left 中：<ol><li>先给所有学生 1 颗糖；</li><li>若ratings<del>i</del> &gt; ratings<del>i-1</del>，则第i名学生的糖比第i-1名学生多1颗；</li><li>若ratings<del>i</del> &lt;= ratings<del>i-1</del>，则第 i 名学生糖数量不变。（交由从右向左遍历时处理。）<br>经过此规则分配后，可以保证所有学生糖数量 满足左规则 。同理，在此规则下从右至左遍历学生成绩并记录在 right 中，可以保证所有学生糖数量<strong>满足左规则</strong>。</li></ol></li><li>同理，在此规则下从右至左遍历学生成绩并将糖果数记录在right中，可保证所有学生糖数量<strong>满足右规则</strong></li><li>最终，取以上2轮遍历left和right对应学生糖果数的最大值 ，这样则<strong>同时满足左规则和右规则</strong>，即得到每个同学的最少糖果数量。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//开两个数组，好理解int candy(vector&lt;int&gt;&amp; ratings) {int len = ratings.size();if(len&lt;2){            return len; //长度即为总糖果数        }vector&lt;int&gt; left(len, 1);    //每个学生最少分配1个糖果vector&lt;int&gt; right(len, 1);    for(int i=0; i&lt;len-1; i++){if(ratings[i+1] &gt; ratings[i]){left[i+1] = left[i]+1;}}for(int i=len-1; i&gt;0; i--){if(ratings[i-1] &gt; ratings[i]){right[i-1] = right[i]+1;}}    int total = 0;for(int i=0; i&lt;len; i++){total += max(left[i], right[i]);}return total;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//开一个数组int candy(vector&lt;int&gt;&amp; ratings) {    int length = ratings.size();    if(length&lt;2){        return length;    }    vector&lt;int&gt; num(length, 1);    for(int i=0; i&lt;length-1; i++){        if(ratings[i+1]&gt; ratings[i]){            num[i+1] = num[i]+1;        }    }    for(int i=length-1; i&gt;0; i--){        if(ratings[i-1] &gt; ratings[i]){            num[i-1] = max(num[i-1] ,num[i]+1);        }    }    return accumulate(num.begin(), num.end(), 0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
