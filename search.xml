<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>论文笔记_MOTR-End-to-End-Multiple-Object-Tracking-with-Transformer</title>
      <link href="/2023/03/02/lun-wen-bi-ji-motr-end-to-end-multiple-object-tracking-with-transformer/"/>
      <url>/2023/03/02/lun-wen-bi-ji-motr-end-to-end-multiple-object-tracking-with-transformer/</url>
      
        <content type="html"><![CDATA[<p>【ECCV2022】 - MOTR：使用Transformer进行端到端的多目标追踪</p><p>【Paper】<a href="https://arxiv.org/abs/2105.03247">https://arxiv.org/abs/2105.03247</a></p><p>【Code】<a href="https://github.com/megvii-research/MOTR">https://github.com/megvii-research/MOTR</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>​        在多目标追踪中，对象/目标的时序建模是一项关键性挑战。现有方法通过基于运动的和基于外观的相似度来进行检测结果的关联，从而实现跟踪；而这种关联的后处理特性，使得其不能够端到端地利用视频序列的时序变量。</p><p>​        基于此，作者提出MOTR。MOTR对DETR进行扩展，并引入track query</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多目标跟踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河工大Pytorch深度学习实践</title>
      <link href="/2023/03/02/he-gong-da-pytorch-shen-du-xue-xi-shi-jian/"/>
      <url>/2023/03/02/he-gong-da-pytorch-shen-du-xue-xi-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230301101130351.png" alt="image-20230301101130351" style="zoom:67%;"><h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><p>可视化问题：可视化训练过程的工具：Visdom</p><p>断点问题：为了应对训练过程中程序崩溃，需要在训练时对模型进行持久化（定期存盘）。</p><p>绘制曲面图形：可以尝试np.meshgrid()</p><h1 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h1><p>随机梯度下降：每次计算的不再是总损失，而是随机选取一个样本计算损失。<br>随机梯度下降，引入随机性，有可能跨过鞍点。</p><p>梯度下降时间复杂度低，但是性能也低；随机梯度下降性能高，但是时间复杂度也高。<br>梯度下降和随机梯度下降的这种：Mini-Batch，批量随机梯度下降，选取一个Batch的样本计算损失。</p><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>《matrix-cook-book》：矩阵计算公式书 </p><p>Pytorch是动态计算图，进行backward之后将计算结果保存之后，计算图会被释放 ，下次forward再重新建立。<br><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230301133845424.png" alt="image-20230301133845424" style="zoom:33%;"><br><code>w.data = w.data - 0.01 * w.grad.data</code>，只是为了修改w的数值，取张量的data进行计算是不会建立计算图的。<br>张量的grad是一个张量，直接使用w.grad会建立计算图。<br><code>w.grad.item()</code>是直接将梯度取出当作Python里的标量。<br><code>w.grad.data.zero_()</code>经过backward()计算的梯度会被累积，更新梯度后记得将grad清零</p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230301135019625.png" alt="image-20230301135019625" style="zoom: 33%;"><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230301135052371.png" alt="image-20230301135052371" style="zoom: 33%;"><h1 id="用Pytorch实现线性回归"><a href="#用Pytorch实现线性回归" class="headerlink" title="用Pytorch实现线性回归"></a>用Pytorch实现线性回归</h1><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230301140354890.png" alt="image-20230301140354890" style="zoom:50%;"><p>所有的模型类均需要继承nn.Module，它是所有神经网络组件的基类。<br>必须要实现构造函数和forward函数；backward不用写，nn.Module会自动实现。</p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230301141518808.png" alt="image-20230301141518808" style="zoom:33%;"><p>model.parameters()会检查model的所有成员，如果有权重，会把它们加入到需要训练的参数集合中。</p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230301142212365.png" alt="image-20230301142212365" style="zoom: 50%;"><h1 id="逻辑斯谛回归"><a href="#逻辑斯谛回归" class="headerlink" title="逻辑斯谛回归"></a>逻辑斯谛回归</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马程序员Linux</title>
      <link href="/2023/03/02/hei-ma-cheng-xu-yuan-linux/"/>
      <url>/2023/03/02/hei-ma-cheng-xu-yuan-linux/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h2><p>个人桌面操作系统：Windows和macOS相互竞争；而服务器操作系统只有Linux</p><h2 id="Linux初识"><a href="#Linux初识" class="headerlink" title="Linux初识"></a>Linux初识</h2><h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><p>Linux系统两部分组成：Linux系统内核和系统级应用程序。<br>内核提供系统最核心的功能，如：调度CPU、调度内存、调度文件系统、调度网络通讯、调度IO等。<br>系统级应用程序，可以理解为出场自带程序，可供用户快速上手操作系统，如：文件管理器、任务管理器、音乐播放等。</p><p><img src="http://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230228141126994.png" alt="image-20230228141126994"></p><p>内核是Linux最核心的存在，系统级应用程序只是锦上添花。<br>Linux内核是免费开源的，任何人都可以下载内核源码查看并修改。</p><h3 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h3><p>任何人都可以获得并修改内核，并且自行集成系统级程序，提供了内核+系统级程序的完整封装，称之为Linux发行版。<br>内核无法被用户直接使用，需要配合应用程序才能被用户使用。<br>在内核之上，封装系统级应用程序，组合在一起称之为Linux发行版。</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230228152430279.png" alt="image-20230228152430279"></p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230228152639147.png" alt="image-20230228152639147"></p><p>不同发行版的基础命令是100%相同的。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机=操作系统（软件）+虚拟硬件。<br>借助虚拟化技术，我们可以在系统中，通过软件，模拟计算机硬件，并给虚拟硬件安装真实的操作系统。</p><h3 id="虚拟化软件"><a href="#虚拟化软件" class="headerlink" title="虚拟化软件"></a>虚拟化软件</h3><p>虚拟化技术可以模拟出计算机硬件，有专门的虚拟化软件可以提供虚拟化技术。<br>VMware WorkStation </p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python积累</title>
      <link href="/2023/03/02/python-ji-lei/"/>
      <url>/2023/03/02/python-ji-lei/</url>
      
        <content type="html"><![CDATA[<ol><li><p>（LeetCode1两数之和）使用一个整数区间控制for循环：<code>for i in range(m, n)</code></p></li><li><p>（LeetCode1）enumerate()函数用于将一个可遍历的数据对象组合为一个索引序列，同时列出数据下标和数据，且可以t通过start参数指定下标从几开始，一般用于for循环中。<br>现有列表list = [7, 8, 9]，<code>for num, i in enumerate(list, [start=0])</code>  ，其遍历结果为<br><code>（0,7）， （1,8）， （2，9）</code></p></li><li><p>（LeetCode1）dict()用于创建一个字典，有三种创建方式：关键字、可迭代对象、映射。<br>关键字：<code>nums = dict(x=0, y=1)</code><br>可迭代对象：<code>nums = dict([('x', 0), ('y', 1)])</code><br>映射：<code>nums = {'x':0, 'y':1}    nums = dict({'x':0, 'y':1}) </code></p></li><li><p>（LeetCode1）判断字典里是否包含某个key：Python3不支持has_key()了，使用in或not in；<code>if i in hashkey：</code>。</p></li><li><p>（LeetCode9回文数）Python中的短除法是//</p></li><li><p>（LeetCode14最长公共前缀）Python不支持自增语法（++）。</p></li><li><p>（LeetCode20有效的括号）list()用于创建一个栈</p></li><li><p>Python==代码规范==<br>（1）命名规范<br>模块命名：模块尽量使用小写命名，首字母保持小写，尽量不用下划线（除非多个单词，且数量不多的情况下）。<br>类命名：大驼峰；私有类可用一个下划线开头。<br>函数命名：一律小写，如有多个单词，用下划线分开。</p><pre><code>类内私有函数命名：用双下划线开头，该函数不可被继承访问。</code></pre><p>变量命名：尽量小写，如有多个单词，可用下划线分开；类内私有变量用双下划线开头，该变量不可被继承访问；常量全大写，如有多个单词，用下划线分类<br>（2）代码规范<br>空一行：类成员函数之间，或者用于区分不同逻辑块。<br>空两行：类与类、类与函数，函数与函数之间。<br>换行：反斜杠</p></li><li><p>列表推导式<code>nums = [i for i in range(1, 11)]</code></p></li><li><p>字典推导式<code>d1={'a':10, 'b':34}  d2={v:k for k,v in d1.items()}  #key和value互换  </code><br><code>d3={k.upper():v for k, v in d1.items()}</code></p></li><li><p>格式化输出：<code>name="han"  print("na name is %s" %name)</code><br>format()格式化字符串<code>print('{0},{1}'.format('laowang', 20))  #1. 通过位置</code><br><code>print('{name}, {age}'.format(age=18, name="han")) #2. 通过关键字参数</code><br><code> a=['han', 20]   print('my name is {0[0]}, age is {0[1]}'.format(a))    #3. 通过映射list</code><br><code>b={'name': 'han', 'age': 18}    print('my name is {name}, age is {age}'.format(**b)) #4.1 解包</code><br><code>print('my name is {info['name']}, age is {info['age']}'.format(info=b))  #4.2  字典映射</code><br>format还可以用来实现填充与对齐。</p></li><li><p>二分查找<br>（1）当搜索区间[left…right]只有两个元素时：<br>· 如果划分区间的逻辑是<code>left=mid+1</code>和<code>right=mid</code>时，<code>while(left&lt;right)</code>退出循环后<code>left==right</code>成立，此时mid正常下取整就行；<br>· 如果划分区间的逻辑是<code>left=mid</code>和<code>right=mid-1</code>时，<code>while(left&lt;right)</code>退出循环后left==right成立，此时为了避免死循环，mid应该上取整。<br>（2</p></li><li><p>拆包：快速提取数据的一种方式<br>(1)<br><code>num1, num2, num3 = [1,2,3]    #对列表拆包，有序的</code><br>对集合拆包，结果是无序的<br>对字典拆包，默认取到的是key，且无序；当然也可以实现取value或者key-value对 </p><p>(2)函数返回值拆包<br><code>high, weight, age = get_my_info()</code><br>(3)通过*和**拆包</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token punctuation">)</span>nums<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>test<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#不简洁</span>test<span class="token punctuation">(</span><span class="token operator">*</span>nums<span class="token punctuation">)</span><span class="token comment">#单*可以跟列表、元组、集合</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> web_site<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>web_site<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>info <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"韩"</span><span class="token punctuation">,</span>    <span class="token string">"web_site"</span><span class="token punctuation">:</span> <span class="token string">"www.baidu.com"</span><span class="token punctuation">,</span>    <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span>test<span class="token punctuation">(</span><span class="token operator">**</span>info<span class="token punctuation">)</span><span class="token comment">#拆包的结果是命名参数</span><span class="token comment"># 更改函数形参名，还需要更改字典的key，故不推荐</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(4)星号拆包和不定长参数搭配使用</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230228091110328.png" alt="image-20230228091110328"><br>(5)</p></li><li><p>不定长参数<br>*args：表示调用函数时多余的<strong>未命名</strong>参数都以元组形式存储到args中；</p><p>**kwargs：表示调用函数时多余的<strong>命名</strong>参数都会以键值对形式存储到kwargs中。</p></li><li><p>匿名函数</p><p>默认自带return，适合书写具有简短代码的函数<br>（1）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_test_func <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">,</span> b<span class="token punctuation">:</span> a<span class="token operator">+</span>b <span class="token comment">#先定义变量指向匿名函数</span>num <span class="token operator">=</span> my_test_func<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）匿名函数可以做实参</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> opt<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>opt<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>fun<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span> x<span class="token operator">+</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）</p><pre class="line-numbers language-py" data-language="py"><code class="language-py"><span class="token comment">#字典排序</span>stus <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"wanglaoshi"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"wanghanshu"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span><span class="token number">19</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"hanshuyao1"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment">#不使用匿名函数</span><span class="token keyword">def</span> <span class="token function">sort_by_age</span><span class="token punctuation">(</span>temp_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> temp_dict<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span>stus<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span>sort_by_age<span class="token punctuation">)</span><span class="token comment">#按age排序</span><span class="token comment">#使用匿名函数</span>stus<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> temp_dict<span class="token punctuation">:</span> temp_dict<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>面向对象<br>（1）定义类<br>定义类有两种方式：新式类和经典类，个人感觉只记住一个吧；</p><p>object是Python里所有类的最顶级父类；</p><p>类名使用大驼峰命名规则；</p><p>实例方法的第一个参数一般是self，表示实例对象本身，当然也可以将self换为其他名字，其作用是一个变量，这个变量指向了实例变量。<br>（2）实例方法和实例属性<br>我们把创建出来的对象成为实例对象，简称对象；所以实例属性就是这个对象的属性；<br>实例方法的定义方法和普通函数类似，唯一区别在于形参中第一个参数是self；通过对象名,方法名()调用。<br>（3）私有属性/方法<br>python中的私有都是假的，只不过不能通过对象名.变量名进行访问。（只是进行了重命名）<br>将__属性名改成了_类名__属性名。<br>（4）__str__()<br>打印某个实例对象时，自定义打印信息，不然会打印object。<br>（5）super<br>如果父类中的方法在派生的子类中不能满足其需求的话，可以在子类中通过重写解决这个问题，但是很多情况下，父类中的方法并不是全部一点不能用，即子类的需求往往是在父类方法实现的功能基础上提出了更多的需求，此时如果我们在子类中重写此方法时就会出现很多冗余代码。解决：在子类重写的方法中通过调用父类中被重写的方法（super）。<br>（6）静态方法<br>如果一个方法不写self即不需要实例对象的引用，此时在定义方法的时候可以用@staticmethod对函数进行修饰，被修饰的函数可以不写self。<br>如果不需要对象，那么就可以讲方法用@staticmethod进行修饰，如此一来此方法就变成了静态方法。<br>可以通过实例对象.静态方法()或者类名.静态方法()方式调用；实例方法只能通过实例对象方法。<br>（7）类属性<br>在class内且在def之外定义的变量<br>（8）类方法<br>使用@classmethod进行修饰，且第一个形参为cls。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5积累</title>
      <link href="/2023/03/02/pyqt5-ji-lei/"/>
      <url>/2023/03/02/pyqt5-ji-lei/</url>
      
        <content type="html"><![CDATA[<ol><li><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20230216162410242.png" alt="image-20230216162410242"><br><code>app=QApplication(sys.argv)</code>Qt制作的每个程序有且仅有一个QApplication；sys.argv当做参数的目的是将运行时的命令参数传递给QApplication对象。<br><code>app.exec_()</code>程序进入循环等待状态，一定要写，不然一闪而过。</p></li><li><p>窗口内的所有控件，若想在窗口中显示，都需要表示它的父亲是谁，而不是直接调用show函数。<br>可以在控件被创建的同时指定父亲（parent参数）；也可以在创建控件之后再指定（setParent函数）</p></li><li><p>PyQt5的自定义信号必须在类属性的位置去定义，不能放在实例方法内。</p></li><li><p>QMessageBox控件中的警告对话框实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">closeEvent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> event<span class="token punctuation">:</span> QtGui<span class="token punctuation">.</span>QCloseEvent<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    ok <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QPushButton<span class="token punctuation">(</span><span class="token punctuation">)</span>    ok<span class="token punctuation">.</span>setText<span class="token punctuation">(</span><span class="token string">u'确定'</span><span class="token punctuation">)</span>    cancel <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QPushButton<span class="token punctuation">(</span><span class="token punctuation">)</span>    cancel<span class="token punctuation">.</span>setText<span class="token punctuation">(</span><span class="token string">u'取消'</span><span class="token punctuation">)</span>    msg <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QMessageBox<span class="token punctuation">(</span>QtWidgets<span class="token punctuation">.</span>QMessageBox<span class="token punctuation">.</span>Warning<span class="token punctuation">,</span> <span class="token string">u'关闭'</span><span class="token punctuation">,</span> <span class="token string">u'是否关闭？'</span><span class="token punctuation">)</span>    msg<span class="token punctuation">.</span>addButton<span class="token punctuation">(</span>ok<span class="token punctuation">,</span> QtWidgets<span class="token punctuation">.</span>QMessageBox<span class="token punctuation">.</span>ActionRole<span class="token punctuation">)</span>    msg<span class="token punctuation">.</span>addButton<span class="token punctuation">(</span>cancel<span class="token punctuation">,</span> QtWidgets<span class="token punctuation">.</span>QMessageBox<span class="token punctuation">.</span>RejectRole<span class="token punctuation">)</span>    <span class="token keyword">if</span> msg<span class="token punctuation">.</span>exec_<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QtWidgets<span class="token punctuation">.</span>QMessageBox<span class="token punctuation">.</span>RejectRole<span class="token punctuation">:</span>        event<span class="token punctuation">.</span>ignore<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        event<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>QLabel（里面显示图片）自适应窗口大小</p></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>label_show_video<span class="token punctuation">.</span>setAutoFillBackground<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyQt5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题记录</title>
      <link href="/2023/03/02/leetcode-shua-ti-ji-lu/"/>
      <url>/2023/03/02/leetcode-shua-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="2023"><a href="#2023" class="headerlink" title="2023"></a>2023</h1><h2 id="2023-03"><a href="#2023-03" class="headerlink" title="2023.03"></a>2023.03</h2><h3 id="0301"><a href="#0301" class="headerlink" title="0301"></a>0301</h3><h4 id="LC287-寻找重复数"><a href="#LC287-寻找重复数" class="headerlink" title="LC287 寻找重复数"></a>LC287 寻找重复数</h4><p>问题的转化值得学习，只不过评论区称之为“奇淫技巧”。<br>好神奇居然刷到了这道题，所以为什么二分模板行不通呢？</p><h4 id="LC2373-矩阵中的局部最大值"><a href="#LC2373-矩阵中的局部最大值" class="headerlink" title="LC2373 矩阵中的局部最大值"></a>LC2373 矩阵中的局部最大值</h4><p>本质上是在实现最大池化。<strong>数组的申请与初始化值得学习</strong>，只不过自己把四层循环写错了，短时间内也没意识到哪里错了，回头再看。<br>。。。。。。。无语了，<strong>命名冲突</strong>，使用了两个n。。。。。。</p><h3 id="0302"><a href="#0302" class="headerlink" title="0302"></a>0302</h3><h4 id="LC面试题05-02"><a href="#LC面试题05-02" class="headerlink" title="LC面试题05.02"></a>LC面试题05.02</h4><p>二进制小数转十进制小数规则记一下。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>202303</title>
      <link href="/2023/03/01/202303/"/>
      <url>/2023/03/01/202303/</url>
      
        <content type="html"><![CDATA[<h1 id="2023-03"><a href="#2023-03" class="headerlink" title="2023.03"></a>2023.03</h1><h2 id="Not-Plans-but-Records-just-Records"><a href="#Not-Plans-but-Records-just-Records" class="headerlink" title="Not Plans, but Records, just Records."></a>Not Plans, but Records, just Records.</h2><h2 id="记得每天看DDLs"><a href="#记得每天看DDLs" class="headerlink" title="记得每天看DDLs"></a>记得每天看DDLs</h2><h3 id="Activity-Inventory-amp-Records"><a href="#Activity-Inventory-amp-Records" class="headerlink" title="Activity Inventory&amp;Records"></a>Activity Inventory&amp;Records</h3><table><thead><tr><th>Date</th><th>TaskID</th><th>Description</th><th>Details</th><th>So？Done？</th></tr></thead><tbody><tr><td>2023.03.01</td><td>01</td><td>决定开始记录这个东西</td><td></td><td>Just do it！</td></tr><tr><td></td><td>02</td><td>LC287；LC2373</td><td>二分;遍历实现最大池化</td><td>详见《LeetCode刷题记录》</td></tr><tr><td></td><td>03</td><td>河工大Pytorch</td><td>Visdom；</td><td>详见《河工大Pytorch深度学习实践》</td></tr><tr><td></td><td>04</td><td>读论文</td><td>ECCV2022 MOTR</td><td>大体看完，剩下消融实验和不足</td></tr><tr><td>2023.03.02</td><td>01</td><td>LC面试题05.02</td><td>二进制小数转十进制小数</td><td></td></tr><tr><td></td><td>02</td><td>组会PPT</td><td>MOTR</td><td>PPT大致好了，没写稿子</td></tr><tr><td></td><td>03</td><td>读论文</td><td>ICLR2021 ViT</td><td>基本理解</td></tr></tbody></table><h2 id="DDLs"><a href="#DDLs" class="headerlink" title="DDLs"></a>DDLs</h2>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo写作经验积累</title>
      <link href="/2022/11/25/hexo-xie-zuo-jing-yan-ji-lei/"/>
      <url>/2022/11/25/hexo-xie-zuo-jing-yan-ji-lei/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/writing">Hexo官方文档</a></p><h2 id="1-布局（Layout）"><a href="#1-布局（Layout）" class="headerlink" title="1. 布局（Layout）"></a>1. 布局（Layout）</h2><h3 id="1-1-三种布局及简单使用"><a href="#1-1-三种布局及简单使用" class="headerlink" title="1.1 三种布局及简单使用"></a>1.1 三种布局及简单使用</h3><p>Hexo有三种默认布局：post、page和draft。在创建三种不同类型文件时，会被分别保存在不同路径下。</p><table><thead><tr><th align="center">布局</th><th align="center">路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">source/_posts</td></tr><tr><td align="center">page</td><td align="center">source</td></tr><tr><td align="center">draft</td><td align="center">source/_drafts</td></tr></tbody></table><p>可通过执行下列命令创建新的文章或页面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不指定[layout]会默认使用_config.yml中的default_layout参数所指定的默认布局。</p><p>另外草稿（draft）不会显示在页面中，可以执行时加上–draft参数，或是把render_drafts参数设为true来预览草稿。<br>可以通过publish命令将草稿移动到source/_posts文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-布局配置修改"><a href="#1-2-布局配置修改" class="headerlink" title="1.2 布局配置修改"></a>1.2 布局配置修改</h3><p>scaffolds目录下有若干md文件，分别对应各种布局的默认front-matter</p><h3 id="1-3-建立自定义布局（模板Scaffold）"><a href="#1-3-建立自定义布局（模板Scaffold）" class="headerlink" title="1.3 建立自定义布局（模板Scaffold）"></a>1.3 建立自定义布局（模板Scaffold）</h3><h2 id="2-访问密码（hexo-blog-encrypt）"><a href="#2-访问密码（hexo-blog-encrypt）" class="headerlink" title="2. 访问密码（hexo-blog-encrypt）"></a>2. 访问密码（hexo-blog-encrypt）</h2><p><a href="https://easyhexo.com/3-Plugins-use-and-config/3-4-hexo-blog-encrypt/"></a></p><ul><li><code>npm install --save hexo-blog-encrypt</code></li></ul><p>另外需要将matery主题目录下_config.yml文件的verifyPassword选项取消激活，改为false。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读论文积累词汇</title>
      <link href="/2022/11/24/yue-du-lun-wen-ji-lei-ci-hui/"/>
      <url>/2022/11/24/yue-du-lun-wen-ji-lei-ci-hui/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="907b7af344db612abe5e9b202d38a9d32a54ccb6e4161c19b926c9330392cae6">b567c004ca2bb5b08891a8e064d889d495465a3ef330030560608dcbde6611978e240c580528511397691cad1de9048ac2b82f92babe80764a7aedbc7a97188b5683846925e47ae396e4ba8bf2f66f3481b9da14c96beb92a98a5e571acb138753dd49b58ab860b3ab1194d481a14ecb64f4cee12c7acd5fa028a18b51ba8b802a9fe442e4faba91243120b407dd27e0ceca9857c9ce57f73313e2f5c02df79b48b30d97622f84d1bf4b864622e59774555771ab5608ffb82d13e53a6b7541aefc6577c5c8a5fb927bdeeed0cb7924362ecf641fa00260cd7f9253406861e9001ea1e1a536d8b96589dd82f50da5d0398d262b5f625c995eabef0692bb7860dc9aaee97d24eddcf0fc23cbdc7293671e888f87e9f89ef5aa46a1cc56241c25a5669ddd485dfc1c4ee51a7a73ee8d0ca6a344df25ca5346bb0ba11d455db3c4016644f46e20a606f36796fa74bf3bae28612668fc3e24130f1a6b5901d49fc6f00baab72119c9cb79b9f81967e65dc83fb979fa3fa5c7bf0ed46673dec250ddad17b2645de8e850d8f514085da815fb2a12fe784cc2ad6ab178be9c7a1fd869e1bd2d97540c7049a1d53b08d932b9549798457ce7f218e8248eb2ac2639b51665af2567325e398831f857284826fe51b77b7e851b10b80d4710b5cc19bf12fc40028abe2ce85d12f3bf6e44ee44ff1c38888bc7e1fa805b4539b7d4ce5f094c5f71958181371223a9efcdee5328b1b6901792db64192fc7ecfe9d8ae53f7e5089306efd9799b5e4c1ee985362b25cd99f2ff21da3559b936f855613144f061498c9c861618545dced443c1c4fdd20ad2f2ef6867b27a03352eda038dae315d94ba67749a712a977ea280ea9b91f9448fd6e06afc54e500f6c40a7f6ded6afda6d82bc1a6049aa9aa61513a1cdd0bb7754ccde97653a89db5d70753da635e0fd406ca6ca17b5989811957c717345dc416b373d523e9295162d76770a53c11143d8cf23deef52c8e5c02c992bb6508ba8357b94bc7281ed6b6122b3544467958ae9639b514fe791a89fed145b83801d7b32e74440442048d3ee1ca35dd9eb2692584ca3324977e34404ad481b6dfc35712de7d2f86094cb4b6f282c35e48e5a7ffcb5be2dd5b16117c5c860191f0d5ecb3f0fbff1f8e2b48ff66b08294e0f9cbce4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">You must enter the password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora使用经验积累</title>
      <link href="/2022/11/23/typora-shi-yong-jing-yan-ji-lei/"/>
      <url>/2022/11/23/typora-shi-yong-jing-yan-ji-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1. 代码块"></a>1. 代码块</h1><p>连续输入三个‘~’再输入想使用的语言，代码块建成之后也可在右下角手动修改所用语言。</p><h1 id="2-MathType公式复制到Typora"><a href="#2-MathType公式复制到Typora" class="headerlink" title="2. MathType公式复制到Typora"></a>2. MathType公式复制到Typora</h1><ol><li><p>在MathType打好公式并复制，需在MathType中将复制格式修改为PlainTex</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123153510409.png" alt="image-20221123153510409"></p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123153127939.png" alt="image-20221123153127939"></p></li><li><p>粘贴到MathType会这样显示：<br><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154440805.png" alt="image-20221123154440805"><br>Typora不会将粘贴过来的$$识别为公式栏，需手动输入$$并按回车创建公式栏</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154657476.png" alt="image-20221123154657476"><br>然后将复制过来的文本删除两端的$$粘贴到公式栏<br><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154805596.png" alt="image-20221123154805596"></p><h1 id="3-条件概率"><a href="#3-条件概率" class="headerlink" title="3. 条件概率"></a>3. 条件概率</h1><p>菜单栏：编辑-&gt;插入符号</p><h1 id="4-与Hexo的小冲突"><a href="#4-与Hexo的小冲突" class="headerlink" title="4. 与Hexo的小冲突"></a>4. 与Hexo的小冲突</h1><p>写公式时可能会出现’{ {‘的字符串，会报错</p><p><img src="C:\Users\23509\AppData\Roaming\Typora\typora-user-images\image-20221123161536878.png" alt="image-20221123161536878"></p><p><a href="https://so.csdn.net/so/search?q=hexo&amp;spm=1001.2101.3001.7020">hexo</a> 的文章渲染使用的是 <code>Nunjucks</code> ，因为在使用<code>mathjax</code>公式，造成了<code>{ {</code>重叠，而它会在生成文章时将那几个大括号识别成自己的语法，这样就会报错。</p><p>用空格隔开就好；</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathType书写公式经验记录</title>
      <link href="/2022/11/23/mathtype-shu-xie-gong-shi-jing-yan-ji-lu/"/>
      <url>/2022/11/23/mathtype-shu-xie-gong-shi-jing-yan-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-中-英文状态下输入"><a href="#1-中-英文状态下输入" class="headerlink" title="1. 中/英文状态下输入"></a>1. 中/英文状态下输入</h1><p>中文状态下输入字母不是斜体的，书写公式时建议切换输入法至英文状态。</p><h1 id="2-常用快捷键"><a href="#2-常用快捷键" class="headerlink" title="2. 常用快捷键"></a>2. 常用快捷键</h1><h2 id="2-1-最常用（Ctrl-字母）"><a href="#2-1-最常用（Ctrl-字母）" class="headerlink" title="2.1 最常用（Ctrl+字母）"></a>2.1 最常用（Ctrl+字母）</h2><p>Tab跳格<br>[Ctrl+H]上标    [Ctrl+L]下标    [Ctrl+J]上下标<br>[Ctrl+9/0]小括号()    [Ctrl+[ ]中括号[]    [Ctrl+shift+[ ]大括号{}        注：ctrl快捷键输出的括号和通常使用shift输出的括号是不一样的。<br>[Ctrl+R]根号radical    [CTRL+F]分式fractional    [Ctrl+/]斜杠分式</p><h2 id="2-2-次常用（前缀键，字母）"><a href="#2-2-次常用（前缀键，字母）" class="headerlink" title="2.2 次常用（前缀键，字母）"></a>2.2 次常用（前缀键，字母）</h2><h2 id="2-3-希腊字母的快捷键（Ctrl-G，字母）"><a href="#2-3-希腊字母的快捷键（Ctrl-G，字母）" class="headerlink" title="2.3 希腊字母的快捷键（Ctrl+G，字母）"></a>2.3 希腊字母的快捷键（Ctrl+G，字母）</h2>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MathType </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白板推导1-1 绪论</title>
      <link href="/2022/11/23/bai-ban-tui-dao-1-1-xu-lun/"/>
      <url>/2022/11/23/bai-ban-tui-dao-1-1-xu-lun/</url>
      
        <content type="html"><![CDATA[<p>对概率的诠释有两大学派：频率派和贝叶斯派。</p><p>后续对观测集采用下面记号：<br>$$<br>{X_{N \times p}} = {\left( { {x_1},{x_2}, \cdots ,{x_N}} \right)^T},{x_i} = {\left( { {x_{i1}},{x_{i2}}, \cdots ,{x_{ip}}} \right)^T}<br>$$<br>这个记号表示有N个样本，每个样本都是p维向量。其中每个观测都是由p(x|θ)生成的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 白板推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Difference between working directory and local repository</title>
      <link href="/2022/11/23/difference-between-working-directory-and-local-repository/"/>
      <url>/2022/11/23/difference-between-working-directory-and-local-repository/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093910760.png" alt="image-20221123093910760"></p><p><strong>working directory（workspace）</strong>：workspace = working directory = project folder，其实就是本地电脑里的文件<br><strong>repository</strong>：实际上就是working directory里的.git隐藏文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093045549.png" alt="image-20221123093045549"></p><p><strong>Step 1: Creating a working directory/workspace</strong></p><p>在本地<strong>新建文件夹</strong>即可实现</p><p><strong>Step 2: Creating a repository</strong></p><p>git commit可在本地生成一个.git文件夹，实际上就是local repository</p><p><strong>Step 3: The working directory and repository in depth</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093412241.png" alt="image-20221123093412241"></p><p><strong>Step 4: Adding a file</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093458051.png" alt="image-20221123093458051"></p><p>在本地新建example.txt文件，这时只在working directory（本地），还没有被add到repository，不能对其进行版本管理。</p><p><strong>Step 5: Adding the file to our repository</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093641206.png" alt="image-20221123093641206"></p><p>git add可实现将example.txt从working directory<strong>复制</strong>到local repository，这样example.txt就可以被Git追踪了</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令解释与踩坑记录</title>
      <link href="/2022/11/22/git-ming-ling-jie-shi-yu-cai-keng-ji-lu/"/>
      <url>/2022/11/22/git-ming-ling-jie-shi-yu-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221122200729751.png"></p><h2 id="1-删除remote-repository的某个文件"><a href="#1-删除remote-repository的某个文件" class="headerlink" title="1. 删除remote repository的某个文件"></a>1. 删除remote repository的某个文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> test.txt<span class="token comment">#在实践中，该命令将workspace和local repository中的文件都删除了</span><span class="token comment">##然后commit+push</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode135：分发糖果</title>
      <link href="/2022/11/13/leetcode135-fen-fa-tang-guo/"/>
      <url>/2022/11/13/leetcode135-fen-fa-tang-guo/</url>
      
        <content type="html"><![CDATA[<p>规则定义：设学生 A 和学生 B 左右相邻，A 在 B 左边；<br>        左规则：当rating<del>B</del> &gt; rating<del>A</del>时，B的糖果比A的糖果数量多。<br>        右规则：当rating<del>A</del> &gt; rating<del>B</del>时，A的糖果比B的糖果数量多。</p><p>相邻的学生中，评分高的学生必须获得更多的糖果 <strong>等价于</strong> 所有学生满足左规则且满足右规则。</p><p>算法流程：</p><ol><li>先从左至右遍历学生成绩 ratings，按照以下规则给糖，并记录在 left 中：<ol><li>先给所有学生 1 颗糖；</li><li>若ratings<del>i</del> &gt; ratings<del>i-1</del>，则第i名学生的糖比第i-1名学生多1颗；</li><li>若ratings<del>i</del> &lt;= ratings<del>i-1</del>，则第 i 名学生糖数量不变。（交由从右向左遍历时处理。）<br>经过此规则分配后，可以保证所有学生糖数量 满足左规则 。同理，在此规则下从右至左遍历学生成绩并记录在 right 中，可以保证所有学生糖数量<strong>满足左规则</strong>。</li></ol></li><li>同理，在此规则下从右至左遍历学生成绩并将糖果数记录在right中，可保证所有学生糖数量<strong>满足右规则</strong></li><li>最终，取以上2轮遍历left和right对应学生糖果数的最大值 ，这样则<strong>同时满足左规则和右规则</strong>，即得到每个同学的最少糖果数量。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//开两个数组，好理解int candy(vector&lt;int&gt;&amp; ratings) {int len = ratings.size();if(len&lt;2){            return len; //长度即为总糖果数        }vector&lt;int&gt; left(len, 1);    //每个学生最少分配1个糖果vector&lt;int&gt; right(len, 1);    for(int i=0; i&lt;len-1; i++){if(ratings[i+1] &gt; ratings[i]){left[i+1] = left[i]+1;}}for(int i=len-1; i&gt;0; i--){if(ratings[i-1] &gt; ratings[i]){right[i-1] = right[i]+1;}}    int total = 0;for(int i=0; i&lt;len; i++){total += max(left[i], right[i]);}return total;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//开一个数组int candy(vector&lt;int&gt;&amp; ratings) {    int length = ratings.size();    if(length&lt;2){        return length;    }    vector&lt;int&gt; num(length, 1);    for(int i=0; i&lt;length-1; i++){        if(ratings[i+1]&gt; ratings[i]){            num[i+1] = num[i]+1;        }    }    for(int i=length-1; i&gt;0; i--){        if(ratings[i-1] &gt; ratings[i]){            num[i-1] = max(num[i-1] ,num[i]+1);        }    }    return accumulate(num.begin(), num.end(), 0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
