<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阅读论文积累词汇</title>
      <link href="/2022/11/24/yue-du-lun-wen-ji-lei-ci-hui/"/>
      <url>/2022/11/24/yue-du-lun-wen-ji-lei-ci-hui/</url>
      
        <content type="html"><![CDATA[<ol><li>It is thus reasonable for us to conjecture that SPP should improve more sophisticated convolutional architectures.</li><li>The SPP-net-based system computes features 24-102× faster than R-CNN, while has better or comparable accuracy. </li><li>The first five layers are convolutional, some of which are followed by pooling layers. These pooling layers can also be considered as “convolutional”, in the sense that they are using sliding windows.</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>‘Typora使用经验积累’</title>
      <link href="/2022/11/23/typora-shi-yong-jing-yan-ji-lei/"/>
      <url>/2022/11/23/typora-shi-yong-jing-yan-ji-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1. 代码块"></a>1. 代码块</h1><p>连续输入三个‘~’再输入想使用的语言，代码块建成之后也可在右下角手动修改所用语言。</p><h1 id="2-MathType公式复制到Typora"><a href="#2-MathType公式复制到Typora" class="headerlink" title="2. MathType公式复制到Typora"></a>2. MathType公式复制到Typora</h1><ol><li><p>在MathType打好公式并复制，需在MathType中将复制格式修改为PlainTex</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123153510409.png" alt="image-20221123153510409"></p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123153127939.png" alt="image-20221123153127939"></p></li><li><p>粘贴到MathType会这样显示：<br><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154440805.png" alt="image-20221123154440805"><br>Typora不会将粘贴过来的$$识别为公式栏，需手动输入$$并按回车创建公式栏</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154657476.png" alt="image-20221123154657476"><br>然后将复制过来的文本删除两端的$$粘贴到公式栏<br><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123154805596.png" alt="image-20221123154805596"></p><h1 id="3-条件概率"><a href="#3-条件概率" class="headerlink" title="3. 条件概率"></a>3. 条件概率</h1><p>菜单栏：编辑-&gt;插入符号</p><h1 id="4-与Hexo的小冲突"><a href="#4-与Hexo的小冲突" class="headerlink" title="4. 与Hexo的小冲突"></a>4. 与Hexo的小冲突</h1><p>写公式时可能会出现’{ {‘的字符串，会报错</p><p><img src="C:\Users\23509\AppData\Roaming\Typora\typora-user-images\image-20221123161536878.png" alt="image-20221123161536878"></p><p><a href="https://so.csdn.net/so/search?q=hexo&amp;spm=1001.2101.3001.7020">hexo</a> 的文章渲染使用的是 <code>Nunjucks</code> ，因为在使用<code>mathjax</code>公式，造成了<code>{ {</code>重叠，而它会在生成文章时将那几个大括号识别成自己的语法，这样就会报错。</p><p>用空格隔开就好；</p>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathType书写公式经验记录</title>
      <link href="/2022/11/23/mathtype-shu-xie-gong-shi-jing-yan-ji-lu/"/>
      <url>/2022/11/23/mathtype-shu-xie-gong-shi-jing-yan-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-中-英文状态下输入"><a href="#1-中-英文状态下输入" class="headerlink" title="1. 中/英文状态下输入"></a>1. 中/英文状态下输入</h1><p>中文状态下输入字母不是斜体的，书写公式时建议切换输入法至英文状态。</p><h1 id="2-常用快捷键"><a href="#2-常用快捷键" class="headerlink" title="2. 常用快捷键"></a>2. 常用快捷键</h1><h2 id="2-1-最常用（Ctrl-字母）"><a href="#2-1-最常用（Ctrl-字母）" class="headerlink" title="2.1 最常用（Ctrl+字母）"></a>2.1 最常用（Ctrl+字母）</h2><p>Tab跳格<br>[Ctrl+H]上标    [Ctrl+L]下标    [Ctrl+J]上下标<br>[Ctrl+9/0]小括号()    [Ctrl+[ ]中括号[]    [Ctrl+shift+[ ]大括号{}        注：ctrl快捷键输出的括号和通常使用shift输出的括号是不一样的。<br>[Ctrl+R]根号radical    [CTRL+F]分式fractional    [Ctrl+/]斜杠分式</p><h2 id="2-2-次常用（前缀键，字母）"><a href="#2-2-次常用（前缀键，字母）" class="headerlink" title="2.2 次常用（前缀键，字母）"></a>2.2 次常用（前缀键，字母）</h2><h2 id="2-3-希腊字母的快捷键（Ctrl-G，字母）"><a href="#2-3-希腊字母的快捷键（Ctrl-G，字母）" class="headerlink" title="2.3 希腊字母的快捷键（Ctrl+G，字母）"></a>2.3 希腊字母的快捷键（Ctrl+G，字母）</h2>]]></content>
      
      
      <categories>
          
          <category> MathType </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>白板推导1-1 绪论</title>
      <link href="/2022/11/23/bai-ban-tui-dao-1-1-xu-lun/"/>
      <url>/2022/11/23/bai-ban-tui-dao-1-1-xu-lun/</url>
      
        <content type="html"><![CDATA[<p>对概率的诠释有两大学派：频率派和贝叶斯派。</p><p>后续对观测集采用下面记号：<br>$$<br>{X_{N \times p}} = {\left( { {x_1},{x_2}, \cdots ,{x_N}} \right)^T},{x_i} = {\left( { {x_{i1}},{x_{i2}}, \cdots ,{x_{ip}}} \right)^T}<br>$$<br>这个记号表示有N个样本，每个样本都是p维向量。其中每个观测都是由p(x|θ)生成的。</p>]]></content>
      
      
      <categories>
          
          <category> 白板推导 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Difference between working directory and local repository</title>
      <link href="/2022/11/23/difference-between-working-directory-and-local-repository/"/>
      <url>/2022/11/23/difference-between-working-directory-and-local-repository/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093910760.png" alt="image-20221123093910760"></p><p><strong>working directory（workspace）</strong>：workspace = working directory = project folder，其实就是本地电脑里的文件<br><strong>repository</strong>：实际上就是working directory里的.git隐藏文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093045549.png" alt="image-20221123093045549"></p><p><strong>Step 1: Creating a working directory/workspace</strong></p><p>在本地<strong>新建文件夹</strong>即可实现</p><p><strong>Step 2: Creating a repository</strong></p><p>git commit可在本地生成一个.git文件夹，实际上就是local repository</p><p><strong>Step 3: The working directory and repository in depth</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093412241.png" alt="image-20221123093412241"></p><p><strong>Step 4: Adding a file</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093458051.png" alt="image-20221123093458051"></p><p>在本地新建example.txt文件，这时只在working directory（本地），还没有被add到repository，不能对其进行版本管理。</p><p><strong>Step 5: Adding the file to our repository</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221123093641206.png" alt="image-20221123093641206"></p><p>git add可实现将example.txt从working directory<strong>复制</strong>到local repository，这样example.txt就可以被Git追踪了</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令解释与踩坑记录</title>
      <link href="/2022/11/22/git-ming-ling-jie-shi-yu-cai-keng-ji-lu/"/>
      <url>/2022/11/22/git-ming-ling-jie-shi-yu-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Junkman996/FigureBed/img/image-20221122200729751.png"></p><h2 id="1-删除remote-repository的某个文件"><a href="#1-删除remote-repository的某个文件" class="headerlink" title="1. 删除remote repository的某个文件"></a>1. 删除remote repository的某个文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> test.txt<span class="token comment">#在实践中，该命令将workspace和local repository中的文件都删除了</span><span class="token comment">##然后commit+push</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode135：分发糖果</title>
      <link href="/2022/11/13/leetcode135-fen-fa-tang-guo/"/>
      <url>/2022/11/13/leetcode135-fen-fa-tang-guo/</url>
      
        <content type="html"><![CDATA[<p>规则定义：设学生 A 和学生 B 左右相邻，A 在 B 左边；<br>        左规则：当rating<del>B</del> &gt; rating<del>A</del>时，B的糖果比A的糖果数量多。<br>        右规则：当rating<del>A</del> &gt; rating<del>B</del>时，A的糖果比B的糖果数量多。</p><p>相邻的学生中，评分高的学生必须获得更多的糖果 <strong>等价于</strong> 所有学生满足左规则且满足右规则。</p><p>算法流程：</p><ol><li>先从左至右遍历学生成绩 ratings，按照以下规则给糖，并记录在 left 中：<ol><li>先给所有学生 1 颗糖；</li><li>若ratings<del>i</del> &gt; ratings<del>i-1</del>，则第i名学生的糖比第i-1名学生多1颗；</li><li>若ratings<del>i</del> &lt;= ratings<del>i-1</del>，则第 i 名学生糖数量不变。（交由从右向左遍历时处理。）<br>经过此规则分配后，可以保证所有学生糖数量 满足左规则 。同理，在此规则下从右至左遍历学生成绩并记录在 right 中，可以保证所有学生糖数量<strong>满足左规则</strong>。</li></ol></li><li>同理，在此规则下从右至左遍历学生成绩并将糖果数记录在right中，可保证所有学生糖数量<strong>满足右规则</strong></li><li>最终，取以上2轮遍历left和right对应学生糖果数的最大值 ，这样则<strong>同时满足左规则和右规则</strong>，即得到每个同学的最少糖果数量。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//开两个数组，好理解int candy(vector&lt;int&gt;&amp; ratings) {int len = ratings.size();if(len&lt;2){            return len; //长度即为总糖果数        }vector&lt;int&gt; left(len, 1);    //每个学生最少分配1个糖果vector&lt;int&gt; right(len, 1);    for(int i=0; i&lt;len-1; i++){if(ratings[i+1] &gt; ratings[i]){left[i+1] = left[i]+1;}}for(int i=len-1; i&gt;0; i--){if(ratings[i-1] &gt; ratings[i]){right[i-1] = right[i]+1;}}    int total = 0;for(int i=0; i&lt;len; i++){total += max(left[i], right[i]);}return total;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//开一个数组int candy(vector&lt;int&gt;&amp; ratings) {    int length = ratings.size();    if(length&lt;2){        return length;    }    vector&lt;int&gt; num(length, 1);    for(int i=0; i&lt;length-1; i++){        if(ratings[i+1]&gt; ratings[i]){            num[i+1] = num[i]+1;        }    }    for(int i=length-1; i&gt;0; i--){        if(ratings[i-1] &gt; ratings[i]){            num[i-1] = max(num[i-1] ,num[i]+1);        }    }    return accumulate(num.begin(), num.end(), 0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
